<script>    import * as THREE from 'three';    import * as CANNON from 'cannon-es'    import {OrbitControls} from "three/examples/jsm/controls/OrbitControls.js"    import CannonDebugger from 'cannon-es-debugger';    const scene = new THREE.Scene();    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);    const renderer = new THREE.WebGLRenderer({antialias: true});    renderer.setSize(window.innerWidth, window.innerHeight);    document.body.appendChild(renderer.domElement);    window.addEventListener("resize", onWindowResize)    const physicsWorld = new CANNON.World({        gravity: new CANNON.Vec3(0, -9.82, 0),    });    const concreteMaterial = new CANNON.Material('concrete')    const plasticMaterial = new CANNON.Material('plastic')    const concretePlasticContactMaterial = new CANNON.ContactMaterial(        concreteMaterial,        plasticMaterial,        {            friction: 0.1,            restitution: 0.7        }    )    physicsWorld.addContactMaterial(concretePlasticContactMaterial)    const groundBody = new CANNON.Body({        type: CANNON.Body.STATIC,        // infinte geometric plane        shape: new CANNON.Plane(),        material: concreteMaterial    });    // rotate ground body by 90 degrees    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);    physicsWorld.addBody(groundBody);    const radius = 1;    const sphereBody = new CANNON.Body({        mass: 5,        shape: new CANNON.Sphere(radius),        material: plasticMaterial    });    physicsWorld.addBody(sphereBody);    // const controls = new OrbitControls(camera, renderer.domElement)    // controls.target.set(0,0,0)    // controls.update()    // controls.enablePan = false    // controls.enableDamping= false    // a light    const geometry = new THREE.SphereGeometry(1, 32, 16);    const material = new THREE.MeshBasicMaterial({color: 0xffff00});    const sphere = new THREE.Mesh(geometry, material);    scene.add(sphere);    const planeGeometry = new THREE.PlaneBufferGeometry(10, 10, 32, 32);    const planeMaterial =  new THREE.MeshBasicMaterial({        color: 0xCC0000,    });    const plane = new THREE.Mesh(planeGeometry, planeMaterial);    plane.rotation.set(-0.5 * Math.PI , 0,0)    scene.add(plane);    camera.position.z = 5;    camera.position.y = 2;    const cannonDebugger = new CannonDebugger(scene, physicsWorld, {        // color: 0xff0000,    });    function animate() {        requestAnimationFrame(animate);        physicsWorld.fixedStep();        sphere.quaternion.copy(sphereBody.quaternion)        sphere.position.copy(sphereBody.position)        plane.position.copy(groundBody.position)        renderer.render(scene, camera);        cannonDebugger.update();    };    function onWindowResize() {        camera.aspect = window.innerWidth / window.innerHeight;        camera.updateProjectionMatrix();        renderer.setSize(window.innerWidth, window.innerHeight)        render();    }    // const projector = new THREE.Pro    const raycaster = new THREE.Raycaster();    function getRayCasterFromScreenCoord(screenX, screenY, camera, projector) {        const mouse3D = new THREE.Vector3();        // Get 3D point form the client x y        mouse3D.x = (screenX / window.innerWidth) * 2 - 1;        mouse3D.y = -(screenY / window.innerHeight) * 2 + 1;        mouse3D.z = 0.5;        projector.setFromCamera(mouse3D, camera);        // return projector.setFromCamera(mouse3D, camera);    }    function findNearestIntersectingObject(clientX, clientY, camera, objects) {        // Get the picking ray from the point        getRayCasterFromScreenCoord(clientX, clientY, camera, raycaster);        // Find the closest intersecting object        // Now, cast the ray all render objects in the scene to see if they collide. Take the closest one.        const hits = raycaster.intersectObjects(objects);        let closest = false;        if (hits.length > 0) {            closest = hits[0];        }        return closest;    }    function bouncingAnimation() {        // requestAnimationFrame( bouncingAnimation );        // sphereBody.position.set(0,5,0)        // let y = sphereBody.position.y        // if(y< 6){        //     sphereBody.position.set(0,y+1,0)        //        // }        return true    };    let rfId = 0    function jump(){            sphereBody.position.y += 0.1            console.log(sphereBody.position.y)            rfId = requestAnimationFrame(jump)        if(sphereBody.position.y >5){            cancelAnimationFrame(rfId)        }    }    function onMouseDown(e) {        // Find mesh from a ray        const entity = findNearestIntersectingObject(e.clientX, e.clientY, camera, [sphere]);        const pos = entity.point;        // console.log("entity,pos",entity,pos)        if (pos !== undefined) {            jump()            // console.log("entity,pos",entity,pos)            // requestAnimationFrame((n)=>{            //     console.log(sphereBody.position.y)            // })            // plane.position.set(0,5,0)            // groundBody.position.set(0, 3, 0)            // console.log("???",groundBody.position)            //            // groundBody.position.set(0, 0, 0)            //            // console.log("working?",groundBody.position)            // groundBody.position.set(0,0,0)            // console.log(sphereBody.position)            // bouncingAnimation()            // sphere.quaternion.copy(sphereBody.quaternion)            // sphere.position.copy(sphereBody.position)        }    }    window.addEventListener("mousedown", onMouseDown, false);    function render() {        renderer.render(scene, camera)    }    // render()    animate();</script><div></div>