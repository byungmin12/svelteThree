<script>    import * as THREE from 'three';    import { onMount } from 'svelte';    import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';    let camera, scene, renderer;    let container    onMount(()=>{        function init(){            camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );            camera.position.set( 0, - 400, 600 );            scene = new THREE.Scene();            scene.background = new THREE.Color( 0xf0f0f0 );            const loader = new FontLoader(undefined);            loader.load('../fonts/Mrs_Saint_Delafield_Regular.json', function (font){                const color = 0x006699;                const matDark = new THREE.LineBasicMaterial({                    color ,                    side : THREE.DoubleSide                })                const matLite = new THREE.MeshBasicMaterial({                    color,                    transparent: true,                    opacity: 0.4,                    side: THREE.DoubleSide                })                const message = '\n   Three.js\nSimple text.'                const shapes = font.generateShapes(message, 100)                const geometry = new THREE.ShapeGeometry(shapes)                geometry.computeBoundingBox()                const xMid = - 0.5 * ( geometry.boundingBox.max.x - geometry.boundingBox.min.x );                geometry.translate( xMid, 0, 0 );                const text = new THREE.Mesh( geometry, matLite );                text.position.z = - 150;                scene.add( text );                const holeShapes = []                const shapesLength = shapes.length                for(let i=0 ; i< shapesLength ; i ++){                    const shape = shapes[i]                    const holeLength = shape.holes.length                    if(shape.holes && holeLength >0 ){                        for(let j =0 ; j<holeLength; j++){                            const hole = shape.holes[j]                            holeShapes.push(hole)                        }                    }                }                shapes.push(...shapes, ...holeShapes)                const lineText = new THREE.Object3D()                for(let i =0 ; i< shapes.length; i++){                    const shape = shapes[i]                    const points = shape.getPoints()                    const geometry = new THREE.BufferGeometry().setFromPoints(points)                    geometry.translate(xMid,0,0)                    const lineMesh = new THREE.Line(geometry, matDark)                    lineText.add(lineMesh)                }                scene.add(lineText)                scene.translateY(-100)                render()            },()=>{},()=>{})            renderer = new THREE.WebGLRenderer({antialias: true})            renderer.setPixelRatio(window.devicePixelRatio)            renderer.setSize(window.innerWidth,window.innerHeight)            container.appendChild(renderer.domElement)            window.addEventListener( 'resize', onWindowResize );        }        function onWindowResize() {            camera.aspect = window.innerWidth / window.innerHeight;            camera.updateProjectionMatrix();            renderer.setSize( window.innerWidth, window.innerHeight );            render();        }        function render(){            renderer.render(scene, camera)        }        init()    })</script><div bind:this={container}></div>